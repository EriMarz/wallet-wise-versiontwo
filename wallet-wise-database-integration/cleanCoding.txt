Server.ts 
-adding a apiRouter to an api folder for modularization
-Why typescript error on server line 18?
-Wonder if some of this SQL logic should be in a controller file and imported in for modularization?

Create app.get for the api adventures to display all adventures
The info is not being pushed to the SQL database 


File organization:
server.ts being outside of the server folder is to be adjusted
Groups overview goes where? 
Groups overview folder was inside componetns folder, but vscode was grouping them together, because there were no files in components. After adding 'testing', 
    notes: we completely reorganized the file structure 

Could file structure look like:
 âœ…client->/src
   âœ… -App.tsx
   âœ… -App.css
    âœ…-components
       âœ… __tests__
        -functional components
            âœ… Button
            button testing (to create)
            âœ… Forms
        -layouts (presentational components)
            âœ…List
            âœ… navbar
            âœ…-header.tsx
            âœ…-footer.tsx
            âœ…-hero
    âœ…-pages
        âœ…__tests__
        âœ…home pages
        âœ…adventure details
        âœ…create Adventure = 
        âœ…groupTripDetails = adventureDetails
        âœ…add expenses
        âœ…*Login*
        âœ…*Registration*
server
    âœ…-controllers
        âœ…adventureController
    âœ…-models
    âœ…-routes
        adventureRoutes
    âœ…-tests
        adventure.test
    âœ…-db connections/config
        âœ…database.ts
   âœ… -server.ts
.env (?) âœ… that makes sense -esm  ty ~ <3

ROOT:
    âœ…client
        src
    âœ…server
    ðŸš¨.env
    âœ…node_modules
    âœ…gitignore
    âœ…readMe
    âœ…packagejson etc
        


What's this mean (replace in the router line):           {/* <Route index element={<Navigate to="expenses" replace />} /> */}

Frontend 
 âœ…CreateAdventure adjust to createAdventure
 âœ…groupTripDetails adjust to adventureDetails
 âœ…modularize App.tsx by compartmentalizing FirstPage into its own component... homePage for cleaner code

Not sure what variant does in Buttons.tsx - need to create a comment / clarify


ðŸª²bugsðŸª²:
-use npm run dev -- --host to allow liveshare participants access to frontend server (guessing this would also work for backend if similar issue arrises)
-10k changes git status (tells us current status of things that are ready for our git commits) and echo "node_modules/" >> .gitignore (the echo double checks that all of our git ignore dependencies were being referenced)
-in restrucuturing our folders, we did not fix the imports for backend and frontend servers. This needed to be adjusted in the index.html file



~~~~ Kim's Notes in database.ts ~~~~~~~~~


//// We export an object that contains a property called query,
// which is a function that returns the invocation of pool.query() after logging the query
// This will be required in the controllers to be the access point to the database
// export default {
//   // Query function with TypeScript types:
//   // - text: SQL query string
//   // - params: Optional array of parameters for prepared statements
//   // - Returns: Promise that resolves to QueryResult (contains rows, rowCount, etc.)
//   query: (text: string, params?: any[]): Promise<QueryResult<any>> => {
//     // console.log("executed query", text);
//     return pool.query(text, params);
//   },
// };

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~Testing Notes~
Because of react components and the way our frontend is set up, we need to install more dependencies than the standard npm install -D vitest. Below is what was added in the install and what they do. 

jsdom (or happy-dom): This package is essential because Vitest runs in a Node.js environment by default, which does not have a browser's Document Object Model (DOM). jsdom (or the faster happy-dom) simulates the browser DOM, allowing your components to render and function correctly during tests.

@testing-library/react: This provides the core utilities for rendering React components in your tests, querying the DOM, and interacting with elements in a way that resembles how a user would.

@testing-library/jest-dom (optional but recommended): This package offers a set of custom matchers (e.g., toBeInTheDocument(), toBeVisible()) that simplify assertions in your tests.

@testing-library/user-event (optional): This library provides a more realistic simulation of user interactions (like typing into an input field or clicking a button) than simple event dispatches

    // screen.debug();
    // expect(1).toBe(1); //dummy test from Kim
    // expect(screen.getByText("Test Button")).toBeInTheDocument();
    //should pass tho bc we have line nine above rendering the button with that name... at least I'd think so .. oh i see

    
